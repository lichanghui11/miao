JavaScript（第一份笔记）


二进制：
* Bit (位）： 只有两种值（1/0）
值： (Values)（六种基本类型）
* numbers
    * JS使用64bits的空间来储存一个数字， 意味着可以储存2^64种不同的数字 
    * 2e5 === 2 * 10^5 
    * 运算符： + - * / %
    * 特殊的数值： 
        * 三种： Infinity / -Infinity / NaN(Not a Number, 这一类型说明在JS层面这个值是没有意义的)
        * NaN !== NaN
        * Infinity == Infinity
* strings
    * Python中支持三引号（’’’)， 功能类似JS里的反点（`）
    * 可以使用双引号和单引号（在JS种这两个符号功能一样）
    * \ (反斜杠） : 转义符（任何跟在反斜杠后面的符号都丢失其原本的含义， 有新的含义）
        * \n: （new line 换行符)
        * \t: （Tab 制表符）
        * \r: （Carriage return 回车符）
        * \b: （Backspace 退格符， 会删除前一个字符）
        * \f: （Form Feed 换页符， 现代浏览器中很少使用）
        * \v: (Vertical Tab 垂直制表符， 现代浏览器很少使用）
        * \uXXXX: (Unicode字符， 用于插入特定的Unicode字符， XXXX是4位16进制数）
        * \xXX: （十六进制转译， 用于表示ASCII字符，  XX是两位十六进制数）
        * \0: （Null Character 空字符）
            * 空字符不会显示， 不影响字符长度， 较少直接使用， 通常在跨语言， 协议解析， 字符编码时候使用
            * 验证空字符存在： charCodeAt(空字符的位置）； 
    * 可利用 + 拼接字符串
* Booleans
    * true / false
* objects
* functions 
* undefined values  （表达有意义的空缺）
    * null （与目标值相比较， 可以检测目标值是否为空）
    * undefined
* 运算符
    * 一元运算符： typeof  -    !
    * 二元运算符： +   -   *   /   %   <   >   >=   <=    ==   ===    !=   !==  in
    * 逻辑运算符: &&   ||   （短路运算， 用于设置默认值 ）
        * || 左边为真， 会提前结束运算； 左边为假， 返回右边的运算结果； 
        * && 左边为假， 会提前结束运算； 左边为真， 返回右边的运算结果； 
    * 三元运算符： ——— ？ ——— ： ———（也叫条件运算符 / 问号表达式）
    * 自动类型转换:  （许多语言不会进行自动类型转换， 不建议刻意使用这些写法）
        * false == 0 // -> true
        * "five" * 3 // -> NaN
        * "3" + 1 // -> 31
        * "3" - 1 // -> 2
        * 8 * null // -> 0
        * == 也会做类型转换
        * 0 / NaN  / ""（空字符串）  使用 == 运算符的时候都会被转换为false
内存与硬盘： 
* 内存的使用需要持续供电， 断电后数据丢失
* 硬盘里面的东西断电之后也仍然存在
ASCII码： 
* 为每一个英文字符编号
* A: 65; a: 97; 空格: 32: …..（这一标准只包含256个符号）

Unicode: 
* 对全世界所有语言符号都指定了唯一编号； （几十万个符号）


语法错误是滞后的

表达式和语句： 
* 表达式会产生一个值
* 表达式可以嵌套（可以组合成任意复杂的运算）
* 最简单的语句可以是一个简单的表达式
* 语句： 
    * 表达式语句
    * 变量声明语句
    * if语句
    * console.log(3); 这是一个表达式语句
* 语句块： 
    * 由{}将多条语句合成一条， 后面不需要加分号

保留字(reserved word), 关键字(key word)

变量名命名规则： 
* 不能以数字开头
* 不能包含标点符号（除了$ / _ 这两个）
* 不能使用保留字 / 关键字

函数： 
* 函数的调用也是一个表达式； 
* alert() 函数只接受一个参数；
* 常见有关数学的函数： 
    * Math.abs(X); // 取X的绝对值
    * Math.max()
    * Math.min()
    * Math.floor(3.66)  //下取整-> 3
    * Math.ceil(3.33) //上取整-> 4
    * Math.trunc(3.55) // 截断整数和小数-> 3
    * Math.round(3.33) // 四舍五入
    * Math.sin(X) //求X的正弦值， X为弧度值（PI为弧度(radians)， 180度为度数（degrees))
    * Math.cos(X) // 求X的余弦值
    * Math.tan(X) // 求X的正切值
    * 弧度与度数转换公式: 
        * radians = degrees * (Math.PI / 180)
    * Number.toFixed(3); // 保留3位小数（保留零位小数时会四舍五入）； 
    * Number.toPrecision(3); // 保留三位有效数字， 长度小于实际位数会四舍五入， 以字符串形式返回格式化后的字符串； 
    * Math.sqrt(x); //求x的平方根； 
    * 取整小技巧： x = 3.25
        * 下取整： x - x % 1;  // -> x = 3; 
        * 上取整： x - x % 1 + 1;  // -> x = 4; 
        * 四舍五入： (x + 0.5) - (x + 0.5) % 1;  // -> x = 3; 

报错中的专业名词： 
* Token（令牌）： 
    * Token是编程语言中的最小组成单位， 代码在编译或解释时会被拆分成一个个的token, 每个token都是代码的一部分； 
    * token可以是: 
        * 关键字(if / else / var),
        * 标识符（变量名 / 函数名 / 自定义的命名）
        * 字面量（ 数字字面量 / 字符串字面量）
        * 运算符（+ = - %）
        * 分隔符（括号 / 分号 / 逗号）
* Identifier（标识符）：
    * identifier是用于命名的一类token
    * 即用来唯一标识某个元素的名称（变量名 / 函数名）

控制流： 
* 本堂课涉及函数： 
    * Number(X); //将X转换为数值； 
    * String(X); //将X转换为字符串；
    * isNaN(X); // 判断X是否是NaN； 
        * 为全局函数， 先将参数强制转换为数字， 再判断是否为NaN; 
            * isNaN("123"); // -> true
    * Number.isNaN(X);  //判断X是否是NaN；
        * ES6引入的方法， 不会对参数进行类型转换， 只有参数严格为NaN时， 才会返回true; 
            * Number.isNaN("124"); // -> false
    * 如果要明确判断是否是NaN， 选择Number.isNaN(), 它不会进行隐式类型转换， 行为更加可靠； 
    * .charCodeAt(X); // 基于字符串的方法调用， 返回X位置的字符的unicode码；
    * String.fromCharCode(num1, num2); // 是String对象的静态方法， 返回对应unicode码位置的字符； 
    *  
* if (表达式) {语句1} else {语句2}； 这个整体是一条语句， 在执行时只会选择语句1或语句2； 
    * 使用过程中要考虑条件之间的包含关系（即条件判断的顺序）

循环： 
* while(  ) { }
* do {  } while (  )
    * 循环至少运行一次； 
* for ( ; ; )  {  }
* break; //这是一个语句， 放在循环中， 立即终止当前循环， 跳出循环体； 
* continue; //这是一个语句， 放在循环中， 终止本次循环的剩余代码， 继续执行下一次循环；
    * 嵌套循环中break; 和continue; 只影响当前所在循环， 如果想跳出多层循环可以使用标签进行标记（当前课程未涉及）： 
```
  theLabel: for (let i = 0; i < 10; i++) {
    for (let j = 3; j < 12; j++) {
      if (true) break theLabel;
    }
  }
```
* switch语句:(类似于多个else if结构if () {} else if () {} else if () {}…);
    * switch 借鉴于c语言和Java语言;
    * 没有break,代码会一直往下运行;
    * switch后括号中的求值结果不满足任意一种case, 就会执行default内容;
    * 这个表达式中判断条件是否成立时不会做类型转换，即使用的是 === ;
    * 花括号{}可选;
```
  switch (表达式（该表达式的结果为下面的任意一个case, 就运行相应代码）) {
    case case1:
      表达式1;
    case case2:
      表达式2;
      break;
    default:
      表达式3;
      break;
  }
```
    * 表达式2是case1和case2共享的;



控制台调试注意事项： 
* 选中的变量会显示其值； 
* 选中的表达式会产生副作用（side effect)(即会进行一次运算， 导致某个值发生额外的变化）
* 控制台可以重新给变量赋值（主动使某个值发生额外的变化）
* 死循环处理：
    * 页面死循环的时候会把单个核的CPU占满， 可以在控制台的任务管理器中关闭当前页面的运行来终止运行； 
    * 死循环也可以通过电脑自带的任务管理器， 按CPU排序， 在靠前的任务中寻找当前网页的运行并终止； 
    * 也可以在调试状态下更改关键变量的值来达到循环终止条件；  


有关于算法优化： 
* 尽量计算次数少， 但是需要相同的结果； 
* 一个m到n之间的奇数求和： 
    * 使用if和循环判断每个数， 再相加， 最慢
    * 使用if和循环判断第一个数， 隔2相加， 优于上一个方案； 
    * 利用等差数列特性， 使用公式（尽量对数据寻找规律， 总结公式， 消耗常数量时间的代码性能最好）
```
  let nums = (n - m) / 2 + 1; //满足条件的数的个数； 
  let result = (m + n) * nums / 2; 
```
    * 随着数据增多， 前两种方案的性能会非常低， 这说明了代码优化的必要性； 

循环课程涉及函数： 
* Math.random(); // 生成0-1之间的随机数； 

实际问题转化成代码过程中， 想清楚每一个细节，  每一个细节问题都可以在代码中体现出来， 而不是写出一段模棱两可/不清不楚的代码；
有的面试要求现场写代码， 不允许调试， 这就需要想清楚每一个细节；  

有关于算法中的经典数列： 
* 斐波那契额数列(Fibonacci sequence)： 0 1 1 2 3 5 8……
    * for循环实现： 
        * 定义三个变量： a / b / c(a + b), 
        * 定义两个变量： a / b , (少一个变量，变量的赋值顺序很重要，  可以开阔思维）
``` 
  b = b + a; 
  a = b - a; 
```
* 有关于素数（Prime）：（出场率极高，优化方案多）
    * 素数唯一性（只能被1和自身整除）；2是唯一偶素数；1不是素数（只有一个因子）
* 列举n以内的素数：
    * 暴力枚举：
        * 从2到（n - 1）使用模运算依次判断；
    * 简单优化暴力枚举：
        * 从2到n/2（包括n/2）使用模运算依次判断；
    * 枚举中遇到的问题：
        * isPrime判定条件的位置需要考虑清楚；
        * 除数需要考虑到被除数的1/2(即j <= i/2)
    * 使用函数判断isPrime() 需要考虑多种情况
        * 是否是整数
            * isInteger()
            * JS自带方法：Number.isInteger()
        * 是否小于零
* isPrime()函数的优化：
    * 循环中只需要遍历到n/2, 因为大于n/2的数除了自身以外不可能被n除尽
    * 进一步： 遍历到Math.sqrt(n); (这一点与完全数原理一样）
    * 进一步： 只遍历Math.sqrt(n)以内的素数； （目前未提及如何写）


有关于算法中的画矩形：（考虑边缘情况思维锻炼）
* for循环画空心/实心矩形


有关于语法糖： 
* 一种编程语言设计中的概念， 某种语法形式， 使代码更简洁更易读（复杂功能的简化）； 
```
  //普通写法
  function add(a, b) {
    return a + b; 
  } 
  //语法糖（箭头函数）
  let add = (a, b) => a + b; 

  //条件语句(if else)的语法糖（即三元运算符）
  let result = (3 > 5) ? "yes" : "no"; 
```

有关于自增运算符： 
* count++:（后置自增）先使用变量当前值，再进行自增； 
* ++count: （前置自增） 先对变量进行自增， 再使用变量的新值； 
* 一个不用太关心的细节： 
    * count++ 与 count += 1 不等价： 
```
  let count = "3"; 
  count++;  //count最终为4（会进行类型转换）
  count += 1;  //count最终为‘31’（不会进行类型转换）
```

有关于加密算法：
* 大的质因素分解是现代加密算法的核心基础
* 有关的一个命令：
    * factor 373747457474626（一个整数） // -> （返回多个素数，相乘为以上输入的整数）
* 质因数分解(Prime Factorization)：
    * 将一个数分解为若干个质数的乘积
    * 当这个数非常大时，质数分解会变的极其困难，计算时间成倍增长
* RSA加密工作原理：
    * 生成两个大质数 p , q; 计算其乘积n = p * q ;
    * n被公开，p, q保密;
    * 利用n与p, q的相关数学性质生成公、私钥对；
    * 公钥加密信息，私钥解密信息；
    * 虽然公钥是公开的，但是由于分解质因数的困难性，攻击者无法通过公钥推导出私钥；
* 一些网络安全技术：
    * 对称加密（AES）：适合快速加密大量数据；
    * 非对称加密（RSA）： 适合密钥交换和身份验证；
    * 数字签名：确保消息的真实性和不可否认性；
    * 哈希算法（SHA）: 为了确保数据完整性；

有关于函数定义方式：（注意： 最好不要在条件判断里定义函数， 函数不会提前声明）
* 函数声明（Function Declaration）(这是一个语句， 没有求值结果）
    * JS运行时会让所有函数声明提前（hoisting）
```
  function greet() {
    console.log("Say hello to me!")
  }
```
* 函数表达式（Function Expression）
    * 将函数赋值给一个变量，不会进行hoisting, 必须定义之后使用
```
  const greet = function() {
    console.log("Say hello to me!")
  };
```
* 箭头函数（Arrow Function）
    * ES6引入，不绑定自己的this, 继承外层上下文的this
```
  const greet () => {
    console.log("Say hello to me!")
  };
```
* 立即执行函数（IIFE Immediately Invoked Function Expression） 
    * 创建后立即执行，用于模块化或封装代码
    * 通常用于创建局部作用域，避免变量污染全局作用域
```
  (function() {
    console.log("Say hello to me immediately!"
  })();
```
* 匿名函数（待补充）
* 构造函数（待补充）


有关于函数的知识点：
* 函数可以嵌套； 
* 局部作用域与全局作用域有相同变量时，函数优先使用局部作用域的变量； 
* 纯函数： 
    * 相同的输入总是产生相同的输出； 
        * 函数输出只依赖输入的参数， 不依赖任何外部状态或环境变量
    * 没有副作用： 
        * 函数不会修改外部变量或数据结构（全局变量或数组对象等）； 
        * 也不会对外产生影响（如打印， 日志记录， 抛出异常或错误等）；   
* 词法作用域： （Lexical Scoping)
    * 代码在书写时已经确定作用域， 并且不会在执行时改变； 
    * 作用域链： （Scope Chain)
        * 当一个变量被引用时， JS引擎会从当前作用域开始， 沿着父级作用域依次向上查找，直到全局作用域， 如果找不到就会抛出ReferenceError;  
* 动态作用域： 
    * JS不支持； 
    * 基于函数调用位置， 沿着调用栈找； 
* 在JS里， 函数只能传变量的值， 不能传变量（有的语言可以）； 
*  调用栈： （后进先出）
    * 调用栈的逻辑概念： 最先启动的函数在调用栈底部， 最后结束运行（函数调用时候的等待关系）； 
    * 调用栈的空间概念： 计算机储存这些函数上下文的地方就叫做调用栈； 
* 调用栈的使用空间是有限制的： 
    * 类似于CPU用于计算， 内存条用于存储， CPU从内存条中取出数据进行计算，再将结果储存到内存条, 内存条的空间是有使用限制的；  
* 剩余参数： 
    * JS中可以接受多余参数， 多余参数不会被使用； 
    * JS中 也可以接受少于函数所要求的参数数量， 剩余未被指定的参数会被赋值为undefined;
* 函数每次调用时， 
    * JS引擎会为该函数创建一个新的执行上下文（Exection Context)（即作用域）
    * 该作用域包含函数的参数， 局部变量， this绑定， 外部作用域引用等信息； 
    * 函数内部变量和参数只在函数内部可见， 函数外部无法访问； 
    * 函数执行完毕之后， 函数内部定义的变量和参数将被从内存中清除； 
    * 如果没有其他引用指向函数内部定义的这些资源， 内存会被垃圾回收机制回收， （但闭包形成时， 一个内部函数引用了外部作用域的变量， 即使外部函数已经返回并销毁，但闭包涉及的变量不会被销毁）
* 闭包(closure): （JS中非常强大的功能，使得函数能够捕获其词法作用域）
    * 闭包产生条件： 
        * 一个内部函数引用了其外部函数作用域中的变量
        * 即使外部函数已经返回并销毁， 但闭包涉及的相关变量定义不会被清除， 因此内部函数仍然可以访问外部函数中的变量； 
    * 闭包即指函数定义时能够“记住”它在某个作用域中的变量， 从而在函数执行完毕后， 依然可以访问这些变量； 
    * 闭包应用场景： 
        * 私有变量： 常用于创建私有变量， 避免全局变量污染和不必要的变量暴露； 
        * 广泛用于事件处理和回调函数； （此处当前课程未涉及， 见后续课程）
    * 闭包的注意事项： 
        * 内存泄露： 闭包引用的定义不会被自动清除， 可能会导致内存泄露（即浪费内存）， 要手动清除不需要的引用， 合理利用闭包； 
        * 性能开销： 
            * 闭包存在会增加内存使用， 编写高性能代码时尽量避免使用闭包； 
        * 理解词法作用域： 
        * 闭包的基础是词法作用域（Lexical Scoping); 
* 递归（recursion):  
    * 递归的基本结构： 
        * 基准情形（Base Case）: 递归的停止条件， 没有BaseCase递归会无限调用， 导致栈溢出； 
        * 递归调用（Recursive Case）： 函数自己调用自己来解决规模更小的子问题；
    * 掌握递归思维方式： 
        * 归纳法思维： 递归类似数学归纳法， 证明递归正确， 需要证明两点： 
            * 基本情形正确； 
            * 假设对某个n正确， 那么对n+1也正确； 
        * 相信递归调用的结果： 
            * 写递归函数时相信递归调用会返回正确的结果， 不必担心内部具体计算过程； （这一点思考方式非常重要）；
            * 此时需要清楚知道函数的参数及返回值（即函数的意义）； 
            * 递归时， 需要往不递归方向推进； （往Base Case方向推进）
            * 递归时应避免重复计算（斐波那契数列有大量重复计算， 但有优化解决方法（见作业））
    * 典型递归问题： （以下例子需要后期补充练习掌握）
        * 斐波那契数列（使用递归效能降低， 有很多重复计算， 越往后， 重复计算越多）
        * 二分查找
        * 迷宫问题
        * 汉诺塔问题





有关于特殊数字：（noi相关题目）
* 水仙花数：对于n位数，每一位的n次方之和等于n
* 完全数(n)：因子（不包含它自身）之和为其自身（1是任何整数的因子）
    * 暴力解法： 遍历2到n-1； （循环接近n次）
    * 优化解法： 遍历2到Math.sprt(n), 计算和的时候要加上与之相对应的因子（即sum = i + n / i）; （循环接近Math.sqrt(n)次）
* 回文数： n倒过来仍然等于n
* 牛顿法计算平方根： （gpt解答）
计算根号n: 
f(x) = x * x - n 
f(x)' = 2 * x
最终公式为： x = (x + n / x) / 2
x的值为渐渐逼近交点；
    * 牛顿法的基本思想是从一个初始猜测值开始（可以取n本身或n的一半）, 通过迭代公式不断逼近方程的根； 
    * 其迭代公式为以上推到结果： x = (x + n / x) / 2
    * 可以使用for循环一定次数
    * 也可以判断新的值和当前值的差是否足够小（即精度是否满足要求）（需要用到while(true)在循环内部进行判断； 





有关于包管理器： 
* 类似于App Store, 专门为开发者和命令行工具设计， 用于简化软件的安装， 更新， 卸载和管理
* Homebrew是macOS和Linux 上非常流行的包管理器
    * 自动处理依赖： 如果所安装的软件依赖于其他工具， Homebrew会自动安装这些依赖； 
    * 可以使用brew update 和 brew upgrade这两个命令轻松更新所安装的软件；
    * 几乎涵盖所有流行的开发工具； 
* 类似的工具
    * APT（用于 Ubuntu/Debian）：APT 是 Linux 发行版 Ubuntu 和 Debian 上的包管理器，命令为 apt-get。
    * Yum 和 DNF（用于 CentOS/Fedora）：这些是 Linux 的 Red Hat 系发行版的包管理器。
    * Chocolatey（用于 Windows）：这是 Windows 上类似 Homebrew 的包管理器，通过命令行管理 Windows 上的软件。

有关于画图函数的小技巧： 
* 画两个实点两个空点的线： ；
    * 满足（x % 4 < 2)条件下画点； 
* 画三个实点两个空点的线： 
    * 满足(x % 5 < 3)条件下画点； 
* 有关于三角函数的特殊值： 
角度 (°)    角度 (rad)   sin(θ)   cos(θ)   tan(θ)   cot(θ)
-----------------------------------------------------------
0°          0           0        1        0        ∞
30°         π/6         1/2      √3/2     1/√3     √3
45°         π/4         √2/2     √2/2     1        1
60°         π/3         √3/2     1/2      √3       1/√3
90°         π/2         1        0        ∞        0

有关于几种经典的计算机图形学算法：
画线段时， 是通过从原点绘制完成之后进行平移， 而不是某一点画到另一个点；
* 简单斜率直线绘制算法:
    * 计算斜率k;
    * k < 1 时，以x轴为步进方向，y = x * k;
    * k > 1时，以y轴为步进方向，x = 1/k * y;
    * 该方法需要运行乘法、浮点数相关计算，性能低，浮点数运算也可能导致精度问题；
* DDA(Digital Differential Analyzer数字差分分析)算法：
使用该方法时， 要注意x与y的增量不一样！！！！
    * 基于斜率公式来决定像素点的选择；
    * 计算斜率k;
    * k < 1时， 以x轴为步进方向，x每增加1，y的增量为k;
    * k > 1时， 以y轴为步进方向，y每增加1， x的增量为1 / k;
    * 累积浮点误差可能导致长直线的精度问题
* Bresenham直线绘制算法：
    * 计算需要画的一段直线x轴和y轴方向上终点到起点的距离：DeltaX, DeltaY;
    * DeltaX > DeltaY,步进方向为x轴；定义一个次轴上的变量d;
        * x轴方向每增加1，变量d增加一个DeltaY,当d大于DeltaX时，y轴方向增加1，变量d减去一个DeltaX;
    * DeltaX < DeltaY, 步进方向为y轴；定义一个次轴上的变量d;
        * y轴方向每增加1，变量d增加一个DeltaX,当d大于DeltaY时，x轴方向增加1，变量d减去一个DeltaY;
    * 只用整数运算，速度快，无浮点误差，精度高；

有关于两种画圆的方法：
* 利用Math.sqrt()计算出每一个y轴的坐标：
    * 利用圆的八对称性，只画出在第一象限的八分之一圆
    * 步进方向为x轴，终止条件为：x <= r / Math.sqrt(2)
    * 每个点的坐标都比较精确，因为y轴方向的点都是Math.sqrt()精确计算得来的
    * 但是Math.sqrt()运算耗时，影响性能
* 消除Math.sqrt()的逼近算法：
    * 利用圆的八对称性，只画出在第一象限的八分之一圆
    * 定义两个y值：
        * y1为当前步进状态值
        * y2为步进状态+1的值
    * 定义两个r值（该值为理论为平方后的值，为了消除Math.sqrt()）
        * r1 = x^2 + y1^2
        * r2 = x^2 + y2^2
    * 比较r1和r2与原半径的差异，选择较近的值作为y轴的步进值
有关于画正弦图像的方法：
* 正弦函数的公式解析： 
    * y = A * sin(B * x + C) + D; 
        * A控制振幅（波的高度）；
        * B控制周期（波的宽度）； 
        * C控制相位（波的水平偏移）； 
        * D控制垂直位移（波的垂直偏移）； 
        * 周期T的计算公式为： T = 2 * PI / B
    * 课堂代码解析： 
        * y = 50 * Math.sin(x / 50) + 200; 
        * B为1/50； 
        * 周期T = 2 * PI / (1/50) = 100 * PI 约等于 314; 
        * 画出来的sin函数图像周期约为314px; 


有关于绘制RGB色彩空间：
* 每种颜色为0到255，共256种
* 使用矩阵进行变换
* 写作业遇到的问题： 
    * 循环内变量的更新不能与循环体本身的变量冲突， 需要重新定义新的变量； 


有关于绘制贝塞尔曲线： （待补充完整）
* 三个控制点： 二阶贝塞尔曲线； 

有关于数组： (array)（数组的更多内容后面逐步补充）
* 数组是值的有序集合； 
* 数组是一种类型的值； 
* [].length; 
* [].push(); // -> 末尾添加， 返回长度； 
* [].pop(); // -> 删除末尾元素， 返回被删除的值； 
* [].unshift(); // -> 开头添加， 返回长度； 
* [].shift(); // -> 开头删除， 返回被删除的值； 
    * pop() 与push()在数组末尾操作，时间复杂度：O(1)
    * shift() 与 unshift() 在数组开头操作，时间复杂度：O(n)
* [].at(); // -> 返回数组中处于某位置的值； 
* [].indexOf(); // -> 返回某个索引处的值； （从前往后）
* [].lastIndexOf(); // -> 返回某个索引处的值； （从后往前找）
* [].slice(m, n);
    * // -> 不传参数， 该函数会从第一个剪切到最后一个（相当于复制）
    * // -> 传一个参数m， 该函数会从第m个剪切到最后一个； 
    * // -> 传两个(m, n)， 该函数会从m个剪切到n之前一个， （左闭右开）； 
* [].concat(); // -> 数组拼接， 不能深度拼接； 
* Array.isArray(); // -> 判断传入的数据类型是不是数组； 
* [].splice(a, b, c);
    *  // -> 从a位置开始， 删除b个元素， 将删除的元素替换为c(…items);
    * // -> 返回值为被删除的元素； 
    * // -> 这个函数非常强大， 可以删除零个元素， 往某个位置插入新的值； 
* [].reverse(); // 将数组反转， 这个函数产生副作用（即数组原地反转）
* [].toReversed(); // 将数组反转， 纯函数（即返回的是新的数组， 不改变原数组）

* 浅拷贝： 
    * 只复制了原数组的引用， 而不会深层次地复制对象内部的结构， 如果数组内部是原始类型（number / string / boolean), 那么元素会被直接复制， 如果元素是引用类型（object / array), 那么拷贝的是引用地址， 而不是对象本身； 
    * slice()与concat()是基于数组的浅拷贝方法； 
* === 运算符： 
    * 浅对比： 只比较两个变量是否引用了同一个内存地址； 
    * 对于原始类型来说， 足够了， 但对于引用类型， 即使内容相同， 引用地址不同也会返回false; 
* isEqual()
    * 该方法用与深对比， 递归地对比引用类型的内部结构（递归到原始类型为止）
* 深拷贝：
    * 递归地复制引用类型的所有嵌套属性和引用， 确保新对象和原对象在内容上完全独立； 
    * 常见深拷贝工具： 
        * JSON.stringify();
        * _.cloneDeep();

* 数组的其他特性： 
    * 稀疏数组： 元素的索引不连续；
    * length属性的特殊性： 可以手动更改， 从而截断或扩展数组； 
    * 解构赋值： 
```
  let [a, b] = [1, 2]; 
  // a = 1, b = 2; 
```
    * 展开运算符： 
```
  let array1 = [1, 2, 3]; 
  let array2 = [...array1, 4, 5]; 
  // array2 = [1, 2, 3, 4, 5]; 
```
* 为了高效的储存和访问，有时需要将多维数组扁平化
* 关于二维数组的扁平化：

```
  // 下面是一个3行4列的二维数组（3 * 4）;
  //m行n列， (m, n)
  let array1 = [
    [1, 2, 3, 4], 
    [5, 6, 7, 8], 
    [9, 10, 11, 12]
  ];
  console.log(array1[0][0]); //-> 1
  console.log(array1[2][3]); //-> 12

  // 下面是扁平化之后的二维数组;
  let array2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

  // 索引转换公式：index = i * n +j
  // i为二维数组中值的行索引
  // j为二维数组中值的列索引
  // n为二维数组中列的数量
  console.log(array2[0]); //-> 1
  console.log(array2[11]); //-> 12
```
* 三维数组扁平化的索引转换公式：
    * l层m行n列
    * 三维中：array[i][j][k]
    * 一维中： index = i * (m * n) + j * n + k
* 数组在内存中的储存方式（根据Chat gpt总结）： 
    * JS的数组不像低级语言中的数组那样是严格的连续内存存储（因为JS中的数组是特殊的对象， 它的储存形式与对像类似， 但其背后肯定有连续形式存储的数组， 实际上会根据使用方式动态选择是连续存储还是对象形式存储）； 
    * 密集数组可能被引擎优化为连续存储； 
    * 稀疏数组往往使用哈希表存储， 性能较差； 
            * 实际上， 数组索引在底层是储存为对象的属性名， 而这些属性名是字符串形式的（即使它们表现为数字）
    * 使用delete删除数组中的值时， 不会删除索引， 只会将这个值替换为undefined; 
    * pop / push / shift / unshift等这些方法会改变索引， 使数组连续；
* 课堂内容总结：（所有语言中数组的最原始的储存方式）
    * 数组中储存的是每个值的内存地址， 每个内存地址都是固定大小的位置（如8个字节）； 
    * 数组是连续的空间存储， 而且它的长度是固定的； 
    * 当数组的空间不够使用时， JS会重新申请一段更大的空间， 将当前数组复制到新的位置， 原来占用的空间会被销毁； 
    * 访问数组中的值时， 利用公式计算每个内存地址： 
        * 元素地址 = 基础地址 + 索引 * 元素的大小； 
    * 计算机在访问数组中的内容时， 不是通过查找， 是通过计算内存地址之后， 直接访问到值； 
        * 比如访问一个名为a的i位置的数据， 先计算出地址 = a + i * size
        * 计算机只要知道了内存地址之后可以直接读取到对应位置的值； 
        * 计算机的一大特点： 只要知道一个地址， 就能够快速读取到对应的值； 
        * 现代CPU一次可以读取1 到 8 个字节， 不能更多， 如果地址更长， 实际上是每八个字节每八个字节地读取； 


有关于对象：（object）
* 是一种用于储存键值对的复合数据类型（值的具名集合）
* 对象（object）是一组无序的，可变的键值对集合
* 键（key）通常是字符串（也可以是Symbol类型）symbol为后续待补充知识点
* 值（value）可以是任意类型的数据
* 定义对象的方法：
    * 对象字面量
```
  let person = {
    name: "Esti",
    age: 25,
  };
```
    * 构造函数（知识点待补充）
    * Object.create方法（知识点待补充）
* 对象的常用操作：
    * 访问属性：
        * 使用(.)或([])
    * 添加或修改属性：
    * 删除属性：
        * delete person.name;
    * 判断属性是否存在：（注意这里判断的是属性名）
        * "name" in person; // ->返回值为Boolean
        * person.hasOwnProperty("name") // -> 返回Boolean
* 遍历对象的属性：
    * for in 
    * Object.keys(传入一个对象); //-> 返回对象自身可枚举属性名的数组
    * Object.values(传入一个对象); //-> 返回对象自身可枚举属性值的数组
    * Object.entries(传入一个对象); //->返回对象自身可枚举属性的键值对数组
* String对象上的方法： 
    * .trim(); // -> 该方法可以删除所有空白字符（160空格， 全角空格， tab等）
    * .charAt(); // -> 拿到某位置上的字符；  
* 关于对象的其他知识点
    * 对象的属性描述符
        * value
        * 可修改性：writable:Boolean
        * 可枚举性： enumerable:Boolean
        * 可否删除或重新定义： configurable: Boolean
    * 原型（prototype）（后续待补充知识点）
    * 对象的不可变性：（对这个知识点目前不熟悉）
        * Object.freeze()
        * Object.seal()
* 包装对象(Wrapper Objects)： 
    * JS为了方便操作原始类型（primitive types) 而提供的一种临时对象
        * 如读取原始类型上的长度： 'hello'.length; // -> 5
        * 课堂新中使用了： 原生对象/原始对象： 直接书写的对象： 'abc' 其实指的是原始类型(Primitive Types )
    * JS有6种原始类型(primitive types): string / number / boolean / null / undefined / symbol; 
    * 原始类型被访问时， JS自动创建一个临时包装对象， 使得它们可以调用原型上的方法， 包装对象是临时的， 一旦使用完就会被销毁； 
    * 如’hello’.length, JS首先创建了一个对象(即构造函数)： String('hello').length; // -> 5
    * 常见的包装对象： String / Number / Boolean (可以调用对应包装对象上的方法）
* 原生对象（Native Objects): 
    * JS预定义的 ， 内置的对象， 是语言规范的一部分， 可直接使用， 
    * 常见原生对象： 
        * Object: JS中所有对象的基类， 定义所有对象的基础功能； 
        * Array: 用于表示数组和操作数组的对象， 提供数组的基本功能（pop() / push()等）
        * Date: 用于处理和操作日期的对象； 
        * Math: 提供数学计算的对象； （Math.random() / Math.floor() 等）
        * RegExp: 用于处理正则表达式的对象； 

* window对象：
    * 浏览器中的全局作用域对象，代表整个浏览器框架
    * 所有在全局作用域声明的变量或函数都会作为window对象的属性存在
* this:
    * this指向的对象取决于所在上下文，尤其是调用方式（此处需要深入理解）
    * 在全局作用域中，this指向window对象
    * 非严格模式下，普通函数的this指向window
```
  function foo() {
    console.log(this); // 指向 window 对象
}
  foo();

```
    * 在严格模式下，普通函数的this指向undefined
```
  'use strict';
  function foo() {
    console.log(this); // undefined
}
  foo();
```
* globalThis:
    * 统一的全局对象引用
    * 在浏览器中等于window
    * 在Node.js中等于global
* for of…循环:
    * 用于遍历可迭代对象的每个值（数组，字符串，map, set等）
* for in…循环:
    * 用于遍历对象的可枚举属性，即对象的键





有关于arguments: 
* arguments是JS函数中的一个隐式对象， 包含所有传递给该函数的参数， 即使没有显示定义的参数， arguments也可以访问到函数调用时传递的参数； 
* 基本特性： 
    * arguments是’类数组‘对象（Array-like object)；
    * 只能在函数内部访问； 
    * arguments具有length属性， 但没有数组的所有方法（push, pop等）； 
    * 无论函数定义中是否列出了对应的参数名， arguments对象函数调用时传递的所有参数； 
    * 可以通过索引访问： arguments[0]
    * 具有length属性； 
    * 非严格模式下， 函数内部修改了命名参数的值， 相应的arguments值也会更新； 
    * 但是修改arguments的值不会影响命名参数的值； 
    * 以上最后两点理解不清晰， 
* ES6e引入了剩余参数： (rest parameter)
    * 是一个真正的数组， 可以直接使用数组的方法； 
    * […args]
    * 只能出现在最后: func(a, b, …args)

有关于对象的属性访问：
* 读取对象属性的常用方法：
    * 点符号（.）
        * 适用于属性名是有效标识符（字母，数字，下划线，美元符号，不以数字开头）（不包含空格，特殊字符）
    * 方括号（[]）
        * 适用于属性名包含空格，特殊字符，数字开头或动态属性名
        * 属性名称必须作为字符串传递（如果不是，会进行自动类型转换）
        * 可以将数组理解为特殊对象，用[数字]的形式进行访问，
* 函数作为属性时，称作方法
* 本堂课涉及函数：
    * join()方法：将数组用指定符号链接成字符串

￼

